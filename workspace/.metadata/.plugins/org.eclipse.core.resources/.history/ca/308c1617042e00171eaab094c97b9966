load gen-tree.maude

view NatSet from TRIV to SET{Nat} * (sort NeSet{Nat} to NeNatSet, sort Set{Nat} to NatSet) is
  sort Elt to NatSet .
endv

fmod CLOUD is
 sort Cloud .
 pr INT .
 pr SET{Nat} * (sort NeSet{Nat} to NeNatSet, sort Set{Nat} to NatSet) .
 inc GEN-TREE{NatSet} * (sort Tree{NatSet} to TreeNatSet, sort Forest{NatSet} to ForestNatSet) .
 subsort TreeNatSet < Cloud .
 op _ : TreeNatSet -> Cloud [ctor] .
 op (_)^_ : Cloud Nat -> Cloud [ctor] .
 op find : ForestNatSet Nat -> TreeNatSet .
 op _U[_]_ : TreeNatSet TreeNatSet Nat -> TreeNatSet .
 op replace : ForestNatSet TreeNatSet Nat -> ForestNatSet .
 op auxfind : TreeNatSet Nat -> TreeNatSet .
 op insertnat : Nat Cloud -> Cloud .

 ---Nuevas Operaciones
 op withoutlast : ForestNatSet -> ForestNatSet .
 op lastelement : ForestNatSet -> TreeNatSet .
 op mergeforest : ForestNatSet ForestNatSet -> ForestNatSet .
 op expandforest : ForestNatSet ForestNatSet Nat -> ForestNatSet .
 op howmanychildren : Int Int -> Int .
 op auxreplace : TreeNatSet TreeNatSet Nat -> ForestNatSet .
 ---
 vars tc t : TreeNatSet .
 vars T T1 OF NF : ForestNatSet .
 var N NC : Nat .
 var NS : NatSet .
 var C : Cloud .
 var N1 NC1 : Int .
 
 ---Nuevas Ecuaciones
 eq withoutlast(t : empty-forest) = empty-forest .
 eq withoutlast(t : T) = t : withoutlast(T) .
 eq lastelement(t : empty-forest) = t .
 eq lastelement(t : T) = lastelement(T) . 
 eq mergeforest(empty-forest,NF) = NF .
 eq mergeforest(OF,NF) = mergeforest(withoutlast(OF),lastelement(OF) : NF) .
 eq expandforest(OF,NF,0) = mergeforest(OF,NF) .
 eq expandforest(OF,NF,s(N)) = expandforest(OF,empty[empty-forest] : NF,N) .
 ceq howmanychildren(N1,NC1) = 0 if NC1 > N1 . 
 eq howmanychildren(N1,NC1) = (N1 - NC1) + 1 .
 eq auxreplace(tc,t,N) = replace(expandforest(children(tc),empty-forest,howmanychildren(N,#children(tc))),t,N) .
 ---
 
 eq (tc) ^ N = auxfind(tc,N) .  
 eq find(t : T, 0) = t .
 eq find(t : T, s(N)) = find(T,N) .
 eq auxfind(t,N) = find(expandforest(children(t),empty-forest,howmanychildren(N,#children(t))),N) .
 
 eq replace(tc : T,t,0) = t : T .
 eq replace(tc : T,t,s(N)) = tc : replace(T,t,N) .
 eq tc U [t] N = root(tc)[auxreplace(tc,t,N)] .  
 eq insertnat(N,C) = insert(N,root(C))[children(C)] .     
 
endfm

fmod INSTRUC is
 pr NAT .
 sort Instruc .

 op tell(_) : Nat -> Instruc [ctor] .
 op skip : -> Instruc [ctor] .
 
endfm

fmod SPAINSTRUC is
 pr INSTRUC .
 sort SpaInstruc .
 subsort Instruc < SpaInstruc .
 pr QID .
 
 vars P1 P2 P3 : SpaInstruc .
 var i : Nat .
 vars X X1 : Qid .
 var c : Nat .
 op [_]_ : Instruc Nat -> SpaInstruc [ctor] .
 op [_]_ : SpaInstruc Nat -> SpaInstruc [ctor] .
 op _||_ : SpaInstruc SpaInstruc -> SpaInstruc [ctor comm assoc] .
 op rec _(_) : Qid SpaInstruc -> SpaInstruc [ctor] .
 op when_do_ : Nat SpaInstruc -> SpaInstruc [ctor] .
 op replaceVar : SpaInstruc Qid SpaInstruc -> SpaInstruc [ctor] .
 op v(_) : Qid -> SpaInstruc [ctor] .
 
 eq replaceVar(P1 || P2,X,P3) = replaceVar(P1,X,P3) || replaceVar(P2,X,P3) .
 eq replaceVar(when c do P1,X,P3) = when c do replaceVar(P1,X,P3) .
 eq replaceVar(tell(c),X,P3) = tell(c) .
 eq replaceVar(skip,X,P3) = skip .
 ceq replaceVar(v(X), X1 ,P3) = P3 if X = X1 .
 eq replaceVar([P1]i, X , P3) = [replaceVar(P1,X,P3)]i .
 
endfm

fmod CCP-SYMBOLS is
 pr CLOUD .
 pr SPAINSTRUC .
 sort Conf .
 
 op <_;_> : SpaInstruc Cloud -> Conf [ctor] .
 
endfm 

mod CCP is
 inc CCP-SYMBOLS .
 
 var C : Nat .
 vars CL CL' : Cloud .
 vars P Q P' : SpaInstruc .
 var SP : SpaInstruc .
 var i : Nat .
 var F : ForestNatSet .
 var X : Qid .
 
 rl [Tell] :
 < tell(C) ; CL > => < skip ; insertnat(C,CL) > .
 crl [Par] : 
 < P || Q ; CL > => < P' || Q ; CL' > if < P ; CL > => < P' ; CL' > /\ P =/= P'  .
 rl [ParSkip] :
 < skip || Q ; CL > => < Q ; CL > .
 rl [SpaSkip] :
 < [skip] i ; CL > => < skip ; CL > .
 crl [WhenDo] : 
 < when C do P ; CL > => < P ; CL > if C in root(CL) .
 crl [SpaInstruc] :
 < [P] i ; CL > => < [P'] i ; CL U [CL'] i > if < P ; (CL) ^ i > => < P' ; CL' > /\ P =/= P' .
 crl [Rec] :
 < rec X(P) ; CL > => < P' ; CL' > if < replaceVar(P,X,rec X(P)) ; CL > => < P' ; CL' > .

endm

mod CCP-TEST is
  pr CCP .

  op init : -> Conf .
  op init2 : -> Conf .
  eq init = < tell(4) || tell(7) ; empty[empty-forest] >  .
  eq init2 = < rec 'x (when 4 do [v( 'x )]0 ) || tell(4) ; empty[empty-forest] > .
endm

---set trace on .

---rew in CCP-TEST : init .
---search [10] in CCP : < tell(4) || tell(7) ; empty[empty-forest] > =>* < skip || tell(4) ; 7[empty-forest] > .
---search in CCP-TEST : init =>* < skip || tell(4) ; 7[empty-forest] > .
rew in CCP : < rec 'x (when 4 do ([v( 'x )]0 || tell(5)) || tell(4) || [tell(4)]0 ; empty[empty-forest] > .

---search in CCP-TEST : init2 =>* < rec 'x (when 4 do [v( 'x )]0 ) || tell(4) ; empty[empty-forest] > .
---show search graph .
