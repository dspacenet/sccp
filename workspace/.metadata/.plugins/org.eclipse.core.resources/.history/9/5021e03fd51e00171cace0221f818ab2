load gen-tree.maude

view NatSet from TRIV to SET{Nat} * (sort NeSet{Nat} to NeNatSet, sort Set{Nat} to NatSet) is
  sort Elt to NatSet .
endv

fmod CLOUD is
 sort Cloud .
 pr INT .
 pr SET{Nat} * (sort NeSet{Nat} to NeNatSet, sort Set{Nat} to NatSet) .
 inc GEN-TREE{NatSet} * (sort Tree{NatSet} to TreeNatSet, sort Forest{NatSet} to ForestNatSet) .
 subsort TreeNatSet < Cloud .
 op _ : TreeNatSet -> Cloud [ctor] .
 op (_)^_ : Cloud Nat -> Cloud [ctor] .
 op find : ForestNatSet Nat -> TreeNatSet .
 op _U[_]_ : TreeNatSet TreeNatSet Nat -> TreeNatSet .
 op replace : ForestNatSet TreeNatSet Nat -> ForestNatSet .
 op auxfind : TreeNatSet Nat -> TreeNatSet .
 op insertnat : Nat Cloud -> Cloud .

 ---Nuevas Operaciones
 op withoutlast : ForestNatSet -> ForestNatSet .
 op lastelement : ForestNatSet -> TreeNatSet .
 op mergeforest : ForestNatSet ForestNatSet -> ForestNatSet .
 op expandforest : ForestNatSet ForestNatSet Nat -> ForestNatSet .
 op howmanychildren : Int Int -> Int .
 op auxreplace : TreeNatSet TreeNatSet Nat -> ForestNatSet .
 ---
 vars tc t : TreeNatSet .
 vars T T1 OF NF : ForestNatSet .
 var N NC : Nat .
 var NS : NatSet .
 var C : Cloud .
 var N1 NC1 : Int .
 
 ---Nuevas Ecuaciones
 eq withoutlast(t : empty-forest) = empty-forest .
 eq withoutlast(t : T) = t : withoutlast(T) .
 eq lastelement(t : empty-forest) = t .
 eq lastelement(t : T) = lastelement(T) . 
 eq mergeforest(empty-forest,NF) = NF .
 eq mergeforest(OF,NF) = mergeforest(withoutlast(OF),lastelement(OF) : NF) .
 eq expandforest(OF,NF,0) = mergeforest(OF,NF) .
 eq expandforest(OF,NF,s(N)) = expandforest(OF,empty[empty-forest] : NF,N) .
 ceq howmanychildren(N1,NC1) = 0 if NC1 > N1 . 
 eq howmanychildren(N1,NC1) = (N1 - NC1) + 1 .
 ---ceq auxreplace(tc,t,N) = replace(children(tc),t,N) if N < #children(tc) .
 eq auxreplace(tc,t,N) = replace(expandforest(children(tc),empty-forest,howmanychildren(N,#children(tc))),t,N) .
 ---
 
 eq (tc) ^ N = auxfind(tc,N) .  
 eq find(t : T, 0) = t .
 eq find(t : T, s(N)) = find(T,N) .
 ---ceq auxfind(t,N) = find(children(t),N) if N < #children(t) .
 eq auxfind(t,N) = find(expandforest(children(t),empty-forest,howmanychildren(N,#children(t))),N) .
 
 ---ceq find(t : T, ) .
 eq replace(tc : T,t,0) = t : T .
 eq replace(tc : T,t,s(N)) = tc : replace(T,t,N) .
 eq tc U [t] N = root(tc)[auxreplace(tc,t,N)] .  
 eq insertnat(N,C) = insert(N,root(C))[children(C)] .     
 
endfm

fmod INSTRUC is
 pr NAT .
 sort Instruc .

 
 op tell(_) : Nat -> Instruc [ctor] .
 op skip : -> Instruc [ctor] .
 ---op _||_ : Instruc Instruc -> Instruc [ctor comm assoc] .


 
endfm

fmod SPAINSTRUC is
 pr INSTRUC .
 sort SpaInstruc .
 subsort Instruc < SpaInstruc .
 pr QID .
 
 vars P1 P2 P3 : Instruc .
 var i : Nat .
 vars X X1 : Nat .
 var c : Nat .
 op [_]_ : Instruc Nat -> SpaInstruc [ctor] .
 op [_]_ : SpaInstruc Nat -> SpaInstruc [ctor] .
 op _||_ : SpaInstruc SpaInstruc -> SpaInstruc [ctor comm assoc] .
 op rec _(_) : Qid SpaInstruc -> SpaInstruc [ctor] .
 op when_do_ : Nat SpaInstruc -> SpaInstruc [ctor] .
 op replaceVar : SpaInstruc Nat SpaInstruc -> SpaInstruc [ctor] .
 op v(_) : Nat -> SpaInstruc [ctor] .
 
 eq replaceVar(P1 || P2,X,P3) = replaceVar(P1,X,P3) || replaceVar(P2,X,P3) .
 eq replaceVar(when c do P1,X,P3) = when c do replaceVar(P1,X,P3) .
 eq replaceVar(tell(c),X,P3) = tell(c) .
 eq replaceVar(skip,X,P3) = skip .
 ceq replaceVar(v(X), X1 ,P3) = P3 if X = X1 .

 
endfm

fmod CCP-SYMBOLS is
 pr CLOUD .
 pr SPAINSTRUC .
 sort Conf .
 
 op <_;_> : SpaInstruc Cloud -> Conf [ctor] .
 
endfm 

mod CCP is
 inc CCP-SYMBOLS .
 
 var C : Nat .
 vars CL CL' : Cloud .
 vars P Q P' : SpaInstruc .
 var SP : SpaInstruc .
 var i : Nat .
 var F : ForestNatSet .

 rl [Tell] :
 < tell(C) ; CL > => < skip ; insertnat(C,CL) > .
 crl [Par] : 
 < P || Q ; CL > => < P' || Q ; CL' > if < P ; CL > => < P' ; CL' > /\ P =/= P'  .
 rl [ParSkip] :
 < skip || Q ; CL > => < Q ; CL > .
 rl [SpaSkip] :
 < [skip] i ; CL > => < skip ; CL > .
 crl [WhenDo] : 
 < when C do P ; CL > => < P ; CL > if C in root(CL) .
 crl [SpaInstruc] :
 < [P] i ; CL > => < [P'] i ; CL U [CL'] i > if < P ; (CL) ^ i > => < P' ; CL' > /\ P =/= P' .
 ---rl [Rec] :
 ---< rec X(P) ; CL > => < replaceX(P) ; CL > .
 ---crl [Rec'] :
 ---< rec X(P) ; CL > => < P' ; CL' > if < P(X -> rec X(P)) ; CL > => < P' ; CL' > /\ P' =/= P .
 ---crl[]
 ---< P ; CL > => < P' ; CL' > if < P ; root(CL)[expandforest(children(CL),empty-forest,7)] > => < P' ; CL' > /\ CL =/= CL' .
 ---crl [Rec] :
 ---< rec X.P ; CL > => < P' ; CL' > if < P (X -> rec X.P) ; CL > => < P' ; CL' > /\ P =/= P'  .
 ---crl [Rec] :
 ---< rec X.P ; CL > => < P' ; CL' > if < P X >
 
endm
---rec X.[tell(c) || when a do X]1
---[tell(c) || when a do rec X.[tell(c) || when a do rec X.[tell(c) || when a do ]]]
set trace on .

red in CCP : replaceVar((v( 1 ) || tell(48)),1 , tell(3)) .

---rew in CCP : < tell(48) || rec X. (X || tell(48)) ; empty[empty-forest] > .
---rew in CCP : < tell(48) || v('x) ; empty[empty-forest] > .
---red in CCP : replaceX(X || tell(5)) .

---rew in CCP : < rec X([(tell(48) || X)]0) ; empty[empty-forest] > .
----rew in CCP : < tell(48) || rec X. (X || tell(48)) ; empty[empty-forest] > . 